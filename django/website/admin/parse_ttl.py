"""
Generated by GPT 5 (with modifications):

Django management command to import a SKOS TTL into FunctionCategory rows.

- Creates a FunctionCategory node for each concept occurrence in the tree.
- If a concept has multiple parents, a *separate* FunctionCategory row (new UUID)
  is created for each parent edge and attached as that parent's child.
- Guards against cycles.

Assumptions:
- <your_app>.models defines FunctionCategory and its ManyToMany "children"
  with related_name="parent_nodes" (or equivalent) per your base classes.
- You don't need to populate color fields; they are ignored.
"""

from __future__ import annotations

import argparse
from typing import Dict, List, Optional, Set

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from django.db.models.fields.related import ManyToManyField

from rdflib import Graph, Namespace, RDF, RDFS, URIRef, Literal

from ..models import FunctionCategory, ControlledGraphList
from ..util import find_database_references

SKOS = Namespace("http://www.w3.org/2004/02/skos/core#")

def load_graph(url: Optional[str], file: Optional[str] = None) -> Graph:
	g = Graph()
	if url:
		g.parse(url, format="turtle")
	elif file:
		g.parse(file, format="turtle")
	else:
		raise ValueError("Provide --url or --file")
	return g


def best_label(g: Graph, concept: URIRef) -> str:
	# Prefer skos:prefLabel (any language), then rdfs:label, then fragment/localname
	labels = list(g.objects(concept, SKOS.prefLabel))
	if not labels:
		labels = list(g.objects(concept, RDFS.label))
	# Choose a label prioritizing @en if present
	chosen: Optional[str] = None
	for lbl in labels:
		if isinstance(lbl, Literal):
			if lbl.language == "en":
				chosen = str(lbl)
				break
			chosen = chosen or str(lbl)
		else:
			chosen = chosen or str(lbl)
	if chosen:
		return chosen
	# Fallback: use fragment or last path segment
	iri = str(concept)
	if "#" in iri:
		return iri.rsplit("#", 1)[1]
	return iri.rstrip("/").rsplit("/", 1)[-1]


def best_definition(g: Graph, concept: URIRef) -> Optional[str]:
	defs = list(g.objects(concept, SKOS.definition))
	if not defs:
		defs = list(g.objects(concept, RDFS.comment))
	for d in defs:
		if isinstance(d, Literal) and (d.language in ("en", None)):
			return str(d)
		return str(d)
	return None


def build_maps(g: Graph):
	# Collect all skos:Concepts
	concepts: Set[URIRef] = set(g.subjects(RDF.type, SKOS.Concept))
	# Include any nodes that participate in broader/narrower even if not typed
	concepts.update(set(g.subjects(SKOS.broader, None)))
	concepts.update(set(g.objects(None, SKOS.broader)))
	concepts.update(set(g.subjects(SKOS.narrower, None)))
	concepts.update(set(g.objects(None, SKOS.narrower)))

	# Labels/defs
	labels: Dict[URIRef, str] = {c: best_label(g, c) for c in concepts}
	defs: Dict[URIRef, Optional[str]] = {c: best_definition(g, c) for c in concepts}

	# Parents via skos:broader (and invert narrower)
	parents: Dict[URIRef, Set[URIRef]] = {c: set() for c in concepts}
	for child, parent in g.subject_objects(SKOS.broader):
		parents.setdefault(child, set()).add(parent)
		concepts.update([child, parent])
	for parent, child in g.subject_objects(SKOS.narrower):
		parents.setdefault(child, set()).add(parent)
		concepts.update([child, parent])

	# Children inverse
	children: Dict[URIRef, Set[URIRef]] = {c: set() for c in concepts}
	for child, pset in parents.items():
		for p in pset:
			children.setdefault(p, set()).add(child)

	return concepts, labels, defs, parents, children


def find_roots(concepts: Set[URIRef], parents: Dict[URIRef, Set[URIRef]]) -> List[URIRef]:
	roots = [c for c in concepts if not parents.get(c)]
	if roots:
		return sorted(roots, key=lambda c: str(c))
	# Fallback: nodes that are not anyone's child
	all_children = set(parents.keys())
	maybe_roots = [c for c in concepts if c not in all_children]
	return sorted(maybe_roots, key=lambda c: str(c))


def create_fc(
	label: str,
	iri: str,
	definition: Optional[str],
	model: type[ControlledGraphList]
) -> ControlledGraphList:
	fc = model(
		name=label,
		identifier=iri,
		definition=definition or "",
	)
	fc.save()
	return fc


def build_tree_and_persist(
	concept: URIRef,
	labels: Dict[URIRef, str],
	defs: Dict[URIRef, Optional[str]],
	parents: Dict[URIRef, Set[URIRef]],
	children: Dict[URIRef, Set[URIRef]],
	parent_row: Optional[FunctionCategory] = None,
	path: Optional[Set[URIRef]] = None,
	model: type[ControlledGraphList] = FunctionCategory,
) -> Optional[ControlledGraphList]:
	"""Create a FunctionCategory row for `concept` under a specific parent row.
	A fresh row is created each call, so multi-parent concepts are duplicated by design.
	Returns the row created for `concept` (or None if cycle blocked).
	"""
	path = set(path or set())
	if concept in path:
		return None  # cycle guard
	path.add(concept)

	node_row = create_fc(
		labels.get(concept, str(concept)), 
		str(concept), 
		defs.get(concept), 
		model
	)

	if parent_row is not None:
		parent_row.children.add(node_row)

	# Recurse to children
	for child in sorted(children.get(concept, set()), key=lambda c: labels.get(c, str(c)).lower()):
		child_row = build_tree_and_persist(
			child, 
			labels, defs, 
			parents, children, 
			node_row, path, 
			model
		)
		# child_row is already linked during its call

	path.remove(concept)
	return node_row

def parse_ttl(model: type[ControlledGraphList], file_url: str):
	"""
	parse a ttl file at the specified url and create model objects for each 
	graph node in the specified model
	"""
	old_objs = list(model.objects.all())

	print(f"fetching data {model._meta.model_name} data from {file_url}")

	try: g = load_graph(file_url)
	except Exception as e:
		raise CommandError(f"Failed to parse TTL: {e}")

	concepts, labels, defs, parents, children = build_maps(g)
	roots = find_roots(concepts, parents)

	if not roots:
		print("No roots found; importing as a forest from all concepts.")
		roots = sorted(concepts, key=lambda c: labels.get(c, str(c)).lower())

	created = 0
	for r in sorted(roots, key=lambda c: labels.get(c, str(c)).lower()):
		row = build_tree_and_persist(r, labels, defs, parents, children, None, None, model)
		if row is not None:
			created += 1

	# update references from old to new
	matched_old_objs: list[ControlledGraphList] = []

	print(f"updating old {model._meta.model_name} references")
	for obj in model.objects.all():
		if obj in old_objs: continue
		new_path = obj.get_name_path()
		print(f"searching for old {new_path} match..")

		# find an old object with a matching path as the new object
		matched_obj: ControlledGraphList = None
		for old_obj in old_objs:
			if old_obj.get_name_path() == new_path:
				matched_obj = old_obj
				break
		
		# if found, replace all references on old object to point to new object
		if matched_obj:
			matched_old_objs.append(matched_obj)
			oldrefs = find_database_references(matched_obj)
			print(f"found match! replacing {len(oldrefs)} references..")
			for refobj, field in oldrefs:
				if isinstance(field, ManyToManyField):
					getattr(refobj, field.name).remove(matched_obj)
					getattr(refobj, field.name).add(obj)
				else: setattr(refobj, field.name, obj)
				print(f"updated field '{refobj.pk}:{field}'")
		
	# remove all old objects
	for obj in old_objs: obj.delete()

	print(f"Import complete. Roots created: {created}")
