import datetime
from typing import Callable

from django.db import models
from django.utils import timezone
from django.core.exceptions import ObjectDoesNotExist
from sortedm2m.fields import SortedManyToManyField

from ..util import *
from .people import Person
from .auxillary_info import RelatedItem, Award
from .submission_info import SubmissionInfo
from .roots import ( LEN_NAME, HssiModel,
	RepoStatus, OperatingSystem, Keyword, Image, Phenomena, Organization, 
	License, InstrumentObservatory, ProgrammingLanguage, FileFormat, 
	Region, DataInput, FunctionCategory, CpuArchitecture, HssiSet,
)

class SoftwareVersion(HssiModel):
	'''A snapshot of the software metadata whenever it's updated to a new version'''
	access = AccessLevel.PUBLIC
	number = models.CharField(max_length=LEN_NAME)
	release_date = models.DateField(blank=True, null=True)
	description = models.TextField(blank=True, null=True)
	version_pid = models.URLField(blank=True, null=True)
	
	# specified for intellisense, defined in Software model
	software: models.Manager['Software']

	@classmethod
	def get_top_field(cls) -> models.Field: return cls._meta.get_field("number")

	def __str__(self): return self.number
	class Meta: ordering = ['number']

class Software(HssiModel):
	access = AccessLevel.CURATOR
	programmingLanguage = models.ManyToManyField(
		ProgrammingLanguage,
		blank=True, 
		related_name='softwares'
	)
	publicationDate = models.DateField(blank=True, null=True)
	publisher = models.ForeignKey(
		Organization,
		on_delete=models.SET_NULL, 
		null=True, 
		blank=True, 
		related_name='softwares_published'
	)
	authors = SortedManyToManyField(Person, related_name='softwares')
	relatedInstruments = models.ManyToManyField(
		InstrumentObservatory,
		blank=True, 
		related_name='softwares'
	)
	relatedObservatories = models.ManyToManyField(
		InstrumentObservatory,
		blank=True, 
		related_name='observatories'
	)
	softwareName = models.CharField(max_length=LEN_NAME)
	version = models.OneToOneField(
		SoftwareVersion,
		on_delete=models.SET_NULL,
		blank=True, null=True,
		related_name='software'
	)
	persistentIdentifier = models.URLField(blank=True, null=True)
	referencePublication = models.ForeignKey(
		RelatedItem,
		on_delete=models.SET_NULL,
		blank=True, null=True,
		related_name="softwares_published"
	)
	description = models.TextField(blank=True, null=True)
	conciseDescription = models.TextField(max_length=200, blank=True, null=True)
	softwareFunctionality = models.ManyToManyField(
		FunctionCategory, 
		blank=True, 
		related_name='softwares'
	)
	documentation = models.URLField(blank=True, null=True)
	dataSources = models.ManyToManyField(
		DataInput, 
		blank=True,
		related_name='softwares'
	)
	inputFormats = models.ManyToManyField(
		FileFormat, 
		blank=True, 
		related_name='softwares_in'
	)
	outputFormats = models.ManyToManyField(
		FileFormat, 
		blank=True, 
		related_name='softwares_out'
	)
	cpuArchitecture = models.ManyToManyField(
		CpuArchitecture,
		blank=True,
		related_name='softwares'
	)
	relatedPublications = models.ManyToManyField(
		RelatedItem,
		blank=True,
		related_name='softwares_referenced'
	)
	relatedDatasets = models.ManyToManyField(
		RelatedItem,
		blank=True,
		related_name='softwares_data'
	)
	developmentStatus = models.ForeignKey(
		RepoStatus,
		on_delete=models.SET_NULL,
		null=True, blank=True,
		related_name='softwares'
	)
	operatingSystem = models.ManyToManyField(
		OperatingSystem, 
		blank=True, 
		related_name='softwares'
	)
	metadataLicense = models.ForeignKey(
		License,
		on_delete=models.SET_NULL, 
		null=True, blank=True, 
		related_name='softwares'
	)
	license = models.ForeignKey(
		License,
		on_delete=models.SET_NULL, 
		null=True, blank=True, 
		related_name='softwares_license'
	)
	licenseFileUrl = models.URLField(blank=True, null=True)
	relatedRegion = models.ManyToManyField(
		Region, 
		blank=True, 
		related_name='softwares_region'
	)
	keywords = models.ManyToManyField(
		Keyword, 
		blank=True, 
		related_name='softwares'
	)
	relatedSoftware = models.ManyToManyField(
		RelatedItem,
		blank=True,
		related_name='softwares_related'
	)
	interoperableSoftware = models.ManyToManyField(
		RelatedItem,
		blank=True,
		related_name='softwares_interoperable'
	)
	funder = models.ManyToManyField(
		Organization,
		blank=True,
		related_name="softwares_funded"
	)
	award = models.ManyToManyField(
		Award,
		blank=True, 
		related_name='softwares'
	)
	codeRepositoryUrl = models.URLField(blank=True, null=True)
	logo = models.ForeignKey(
		Image,
		on_delete=models.SET_NULL, 
		null=True, blank=True, 
		related_name='softwares'
	)
	relatedPhenomena = models.ManyToManyField(
		Phenomena, 
		blank=True,
		related_name='softwares'
	)
	submissionInfo = models.OneToOneField(
		SubmissionInfo,
		on_delete=models.SET_NULL,
		blank=True, null=True,
		related_name='software'
	)

	# specified for intellisense, defined in other model
	visible: models.Manager['VisibleSoftware']

	# autogenerated django integer choice string getter
	get_developmentStatus_display: Callable[[], str]

	class Meta:
		ordering = ['softwareName']
		verbose_name_plural = '  Software'

	@classmethod
	def get_top_field(cls) -> models.Field: return cls._meta.get_field("softwareName")

	@classmethod
	def get_subfields(cls):
		subfields = super().get_subfields()
		for i, field in enumerate(subfields):
			if field.name == cls.submissionInfo.name:
				subfields.pop(i)
				break
		return subfields

	def __str__(self): return self.softwareName

	'''if the software is visible on the website'''
	def is_visible(self) -> bool:
		try:
			_ = self.visible
			return True
		except ObjectDoesNotExist: 
			return False

class VisibleSoftware(HssiSet):
	"""Stores ids to flag softwares with the given ids as visible"""
	access = AccessLevel.PUBLIC
	target_model = Software

	class Meta: verbose_name_plural = 'Visible software'
	def __str__(self): return str(self.id)

class SoftwareEditQueue(HssiModel):
	"""
	The idea here is that submitters can request to make edits to their 
	submissions by accessing the page for their software package, then press a 
	button to request to edit their submission. When the option is selected,
	a new entry will be made into this model, pointing to the target software
	to be edited, then an email will be sent to the submitter email linking to
	the edit page made from the entry in this model. The edit page will expire 
	some time after it is created. This allows for secure editing of submissions
	by the submitter with a randomly generated url based on the UUID of the 
	object in this model's pk without managing profiles for submitters.
	"""

	default_expire_delta = datetime.timedelta(hours=5)

	access = AccessLevel.PUBLIC
	created = models.DateTimeField(null=True, blank=True)
	expiration = models.DateTimeField(null=True, blank=True)
	target_software = models.ForeignKey(
		Software, 
		on_delete=models.CASCADE,
		null=True, blank=True,
		related_name="submission_edit_queue"
	)

	def is_expired(self) -> bool:
		"""
		returns true if the queue entry was created longer ago than the 
		threshold specifies, the entry should be deleted if this returns true
		"""
		if not self.expiration: return True
		return timezone.now() > self.expiration
	
	@classmethod
	def get_latest_expiry(cls, target: Software) -> 'SoftwareEditQueue':
		"""
		grab the edit queue item that corresponds to the specified target 
		which has the latest expiry date/time
		"""
		items = cls.objects.filter(target_software=target.pk)
		latest = items.first()
		if not latest: return None
		for item in items:
			if latest.expiration < item.expiration: latest = item
		return latest

	@classmethod
	def create(cls, target: Software, expiration: datetime.datetime = None) -> 'SoftwareEditQueue':
		queue_item = cls()
		queue_item.created = timezone.now()
		queue_item.target_software = target
		if not expiration: expiration = queue_item.created + cls.default_expire_delta
		queue_item.expiration = expiration
		queue_item.save()
		return queue_item
