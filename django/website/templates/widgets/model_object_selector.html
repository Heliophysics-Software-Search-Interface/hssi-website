{% load unique_id %}
{% unique_id "modelbox" as uid %}

<style>
  .modelbox-container {
    position: relative;
  }
  
  .modelbox-options {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    background: white;
    border: 1px solid #ccc;
    border-top: none;
    z-index: 1000;
    list-style: none;
    margin: 0;
    padding: 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .modelbox-options li {
    padding: 8px;
    cursor: pointer;
  }
  
  .modelbox-options li:hover {
    background:rgb(154, 181, 255);
  }

  .modelbox-options li.highlighted {
    background:rgb(154, 181, 255);
  }
</style>

<div class="modelbox-container">
  <ul 
    class="modelbox-options {{ uid }}-options" 
    style="display: none;"
  > </ul>
  <input 
    type="text" 
    autocomplete="off"
    name="{{ widget.name }}" 
    value=""
    {% include "django/forms/widgets/attrs.html" %}
    class="modelbox-input {{ uid }}-input"
  >
</div>

<script>(function(){

  const optionList = document.getElementsByClassName("{{ uid }}-options")[0];
  optionList.remove();
  document.body.appendChild(optionList);

  /** @type {HTMLInputElement} */
  let input = document.getElementsByClassName("{{ uid }}-input")[0];

  /** @type {Array<HTMLInputElement>} */
  const allInputs = [input]

  /** @type {HTMLLIElement} */
  const filteredOptionElements = [];
  
  let selectedOption = -1;

  // create a list of every object in the modelbox model
  const all = [
      {% for id, name, kw in widget.choices %}
          {
            id: "{{ id }}",
            name: "{{ name }}",
            keywords: [
              {% for k in kw %}
                "{{ k }}".toLocaleLowerCase(){% if not forloop.last %},{% endif %}
              {% endfor %}
            ]
          } {% if not forloop.last%},{% endif %}
      {% endfor %}
  ];

  // create a list element in the ul for each item
  for (let op of all) {
    const li = document.createElement('li');
    li.tabIndex = 0;
    li.style.userSelect = 'none';
    li.style.display = 'none'
    li.data = op;
    li.innerText = op.name;
    optionList.appendChild(li);
    li.addEventListener('click', selectOption.bind(null, li));
  }

  // add event listeners for interacting with dropdown
  addDropdownEvents(input);

  /** @param {FocusEvent} e  */
  function inputFocusOut(e) {
    /** @type {HTMLElement} */
    const target = e.target;
    const focusTarget = e.relatedTarget;
    if (target != allInputs[allInputs.length - 1]) {
      if(target.value.trim().length <= 0) {
        target.remove();
        const index = allInputs.indexOf(target)
        allInputs.splice(index, 1);
      }
    }
    if (focusTarget == null){
      hideOptions();
      return;
    }
    if(!focusTarget.parentElement.classList.contains('modelbox-options')){
      hideOptions();
      return;
    }
  }

  /** @param {KeyboardEvent} evt  */
  function handleOptionKeyNav(evt){
    let optionChanged = -1;
    switch (evt.key) {
      
      // select next option
      case 'ArrowDown':
        if(optionList.style.display != 'none'){
          optionChanged = selectedOption;
          selectedOption += 1;
          if(selectedOption >= filteredOptionElements.length){
            selectedOption = 0;
          }
        }
        break;
      
      // select previous option
      case 'ArrowUp':
        if(optionList.style.display != 'none'){
          optionChanged = selectedOption;
          selectedOption -= 1;
          if(selectedOption < 0){
            selectedOption = filteredOptionElements.length - 1;
          }
        }
        break;
      
      // unfocus current input if backspace on empty and multi fields
      case 'Backspace':
        if(input.value.length <= 0 && allInputs.length > 1) {
          let index = allInputs.indexOf(evt.target);
          if(index <= 0){
            allInputs[1].focus();
          }
          else {
            index -= 1;
            allInputs[index].focus();
          }
        }
        break;

      // confirm selected option
      case 'Enter':
      if(selectedOption >= 0){
        const option = filteredOptionElements[selectedOption];
        selectOption(option);
      }
      else {
        confirmInput(input);
      }
      evt.preventDefault();
        break;
    }

    // highlight/unhighlight and scroll selected option into view
    if(selectedOption >= 0){
      if(optionChanged >= 0){
        const option = filteredOptionElements[optionChanged];
        option.classList.remove("highlighted");
      }
      const option = filteredOptionElements[selectedOption];
      option.scrollIntoView({block: 'nearest'});
      option.classList.add("highlighted");
    }
  }

  /** 
    @param {HTMLInputElement} elem
    filter and show dropdown based on char field value
  */
  function filterOptions(elem) {
    if(selectedOption >= 0) {
      const option = filteredOptionElements[selectedOption];
      option.classList.remove("highlighted");
    }

    selectedOption = -1;
    filteredOptionElements.length = 0;

    // show all matching elements, hided non-matching elements
    splitInput = elem.value.toLocaleLowerCase().split(' ');
    outer: for (option of optionList.children) {
      if (elem.value.length <= 0) {
        option.style.display = 'block';
        filteredOptionElements.push(option);
        continue outer;
      }
      for (kw of option.data.keywords) {
        for (inWord of splitInput) {
          if (kw.includes(inWord)){
            option.style.display = 'block';
            filteredOptionElements.push(option);
            continue outer;
          }
        }
      }
      option.style.display = 'none'
    }

    let rect = elem.getBoundingClientRect();
    optionList.style.left = `${rect.left + window.scrollX}px`;
    optionList.style.top = `${rect.bottom + window.scrollY}px`;
    optionList.style.width = `${rect.width}px`
    optionList.style.display = 'block';
  };

  /** @param {Event} evt */
  function focusInput(evt) {
    input = evt.target;
    filterOptions(evt.target);
  }

  function selectOption(option) {
    input.value = option.data.name;
    input.setAttribute('data-id', option.data.id);
    option.classList.remove("highlighted");
    selectedOption = -1;
    hideOptions();
    confirmInput(input);
  }

  // hide the dropdown
  function hideOptions() {
    optionList.style.display = 'none';
  };
  
  /** @param {HTMLElement} elem */
  function addDropdownEvents(elem) {
    elem.addEventListener('focus', focusInput);
    elem.addEventListener('input', focusInput);
    elem.addEventListener('keydown', handleOptionKeyNav);
    elem.addEventListener('focusout', inputFocusOut);
  }

  /** @param {HTMLElement} elem */
  function removeDropdownEvents(elem) {
    elem.removeEventListener('focus', filterOptions);
    elem.removeEventListener('input', filterOptions);
    elem.removeEventListener('keydown', handleOptionKeyNav);
    elem.removeEventListener('focusout', inputFocusOut);
  }

  /** @param {HTMLInputElement} textbox */
  function confirmInput(textbox) {
    const lastInput = allInputs[allInputs.length - 1];
    if(input != lastInput){
      input = lastInput;
    }
    else{
      const newInput = input.cloneNode(true);
      newInput.value = "";
      addDropdownEvents(newInput);
      input.parentNode.appendChild(newInput);
      allInputs.push(newInput);
      
      input = newInput;
    }
    input.focus();
  }

})()</script>
