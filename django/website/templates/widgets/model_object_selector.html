{% load unique_id %}
{% unique_id "modelbox" as uid %}

<style>
  .modelbox-container {
    position: relative;
  }
  
  .modelbox-options {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    background: white;
    border: 1px solid #ccc;
    border-top: none;
    z-index: 1000;
    list-style: none;
    margin: 0;
    padding: 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .modelbox-options li {
    padding: 8px;
    cursor: pointer;
  }
  
  .modelbox-options li:hover {
    background:rgb(154, 181, 255);
  }

  .modelbox-options li.highlighted {
    background:rgb(154, 181, 255);
  }
</style>

<div class="modelbox-container">
  <ul 
    class="modelbox-options {{ uid }}-options" 
    style="display: none;"
  > </ul>
  <div>
    <div style="position: relative; display: block;">
      <input 
        type="text" 
        autocomplete="off"
        name="{{ widget.name }}" 
        value=""
        {% include "django/forms/widgets/attrs.html" %}
        class="modelbox-input {{ uid }}-input"
      >
      {% if widget.dropdown_button == "true" %}
      <button 
        type="button"
        style="
          position:absolute;
          right: 0;
          top: 0;
          translateY(-50%);
          height: 100%;
          aspect-ratio: 1;
          border-left: #ccc solid 1px;
        "
        class="dropdown-btn {{ uid }}-dropdown-btn"
      >â–¼</button>
      {% endif %}
    </div>
  </div>
</div>

<script>(function(){

  const properties = {
    caseSensitiveFiltering: {{ widget.case_sensitive_filtering }},
    multiSelect: {{ widget.multi_select }},
    filterOnFocus: {{ widget.filter_on_focus }},
    dropdownButton: {{ widget.dropdown_button }},
    dropdownOnFocus: {{ widget.dropdown_on_focus }},
    dropdownOnBlank: {{ widget.dropdown_on_blank }},
    newObjectField: null,
  }

  const optionList = document.getElementsByClassName("{{ uid }}-options")[0];
  optionList.remove();
  document.body.appendChild(optionList);

  /** @type {HTMLInputElement} */
  let input = document.getElementsByClassName("{{ uid }}-input")[0];
  addDropdownEvents(input);

  /** @type {Array<HTMLInputElement>} */
  const allInputs = [input]

  /** @type {HTMLLIElement} */
  const filteredOptionElements = [];
  
  let selectedOption = -1;

  // create a list of every object in the modelbox model
  const all = [
      {% for id, name, kw in widget.choices %}
          {
            id: "{{ id }}",
            name: "{{ name }}",
            keywords: [
              {% for k in kw %}
                "{{ k }}"{% if not forloop.last %},{% endif %}
              {% endfor %}
            ]
          } {% if not forloop.last%},{% endif %}
      {% endfor %}
  ];
  if(!properties.caseSensitiveFiltering){
    for(choice of all){
      for(i in choice.keywords){
        choice.keywords[i] = choice.keywords[i].toLocaleUpperCase()
      }
    }
  }

  // create a list element in the ul for each item
  for (let op of all) {
    const li = document.createElement('li');
    li.tabIndex = 0;
    li.style.userSelect = 'none';
    li.style.display = 'none'
    li.data = op;
    li.innerText = op.name;
    optionList.appendChild(li);
    li.addEventListener('click', selectOption.bind(null, li, false));
  }

  /** @param {Event} evt */
  function dropdownButtonClick(evt) {
    /** @type {HTMLButtonElement} */
    let button = evt.target;
    input = button.previousElementSibling;
    input.focus();
    filterOptions(input, "");
  }

  /** @param {Event} evt */
  function inputFocusIn(evt) {
    /** @type {HTMLInputElement} */
    const isFocusEvt = evt instanceof FocusEvent;
    const target = evt.target;
    input = target;
    if(properties.dropdownOnFocus || !isFocusEvt){
      let filterStr = isFocusEvt && !properties.filterOnFocus ? "" : null;
      if(properties.dropdownOnBlank) filterOptions(target, filterStr);
      else {
        if(target.value.length > 0) filterOptions(target, filterStr);
        else hideOptions();
      }
    }
  }

  /** @param {FocusEvent} e  */
  function inputFocusOut(e) {
    /** @type {HTMLElement} */
    const target = e.target;
    const focusTarget = e.relatedTarget;
    if (target != allInputs[allInputs.length - 1]) {
      if(target.value.trim().length <= 0) {
        target.remove();
        const index = allInputs.indexOf(target)
        allInputs.splice(index, 1);
      }
    }
    if (focusTarget == null){
      hideOptions();
      return;
    }
    if(!focusTarget.parentElement.classList.contains('modelbox-options')){
      hideOptions();
      return;
    }
  }

  /** @param {KeyboardEvent} evt  */
  function handleOptionKeyNav(evt){
    let optionChanged = -1;
    switch (evt.key) {
      
      // select next option
      case 'ArrowDown':
        if(optionList.style.display != 'none'){
          optionChanged = selectedOption;
          selectedOption += 1;
          if(selectedOption >= filteredOptionElements.length){
            selectedOption = 0;
          }
        }
        break;
      
      // select previous option
      case 'ArrowUp':
        if(optionList.style.display != 'none'){
          optionChanged = selectedOption;
          selectedOption -= 1;
          if(selectedOption < 0){
            selectedOption = filteredOptionElements.length - 1;
          }
        }
        break;
      
      // unfocus current input if backspace on empty and multi fields
      case 'Backspace':
        if(input.value.length <= 0 && allInputs.length > 1) {
          let index = allInputs.indexOf(evt.target);
          if(index <= 0){
            allInputs[1].focus();
          }
          else {
            index -= 1;
            allInputs[index].focus();
          }
        }
        break;

      // confirm selected option
      case 'Enter':
        if(selectedOption >= 0){
          const option = filteredOptionElements[selectedOption];
          selectOption(option);
        }
        else {
          confirmInput(input);
        }
        evt.preventDefault();
        break;
      
      // summon autocomplete dropdown with ctrl + space
      case ' ':
        if(evt.ctrlKey){
          filterOptions(input);
        }
        break;
    }
    // highlight/unhighlight and scroll selected option into view
    if(selectedOption >= 0){
      if(optionChanged >= 0){
        const option = filteredOptionElements[optionChanged];
        option.classList.remove("highlighted");
      }
      const option = filteredOptionElements[selectedOption];
      option.scrollIntoView({block: 'nearest'});
      option.classList.add("highlighted");
    }
  }

  /** 
    @param {HTMLInputElement} elem
    filter and show dropdown based on char field value
  */
  function filterOptions(elem, filterStr = null) {
    if(selectedOption >= 0) {
      const option = filteredOptionElements[selectedOption];
      option.classList.remove("highlighted");
    }

    selectedOption = -1;
    filteredOptionElements.length = 0;

    // show all matching elements, hide non-matching elements
    let inputVal = filterStr != null ? filterStr : elem.value;
    if (!properties.caseSensitiveFiltering) {
      inputVal = inputVal.toLocaleUpperCase();
    }
    const splitInput = inputVal.split(' ');
    outer: for (option of optionList.children) {
      if (inputVal.length <= 0) {
        option.style.display = 'block';
        filteredOptionElements.push(option);
        continue outer;
      }
      for (kw of option.data.keywords) {
        for (inWord of splitInput) {
          if (kw.includes(inWord)){
            option.style.display = 'block';
            filteredOptionElements.push(option);
            continue outer;
          }
        }
      }
      option.style.display = 'none'
    }

    let rect = elem.getBoundingClientRect();
    optionList.style.left = `${rect.left + window.scrollX}px`;
    optionList.style.top = `${rect.bottom + window.scrollY}px`;
    optionList.style.width = `${rect.width}px`
    optionList.style.display = 'block';
  };

  function selectOption(option, focusNext = true) {
    input.value = option.data.name;
    input.setAttribute('data-id', option.data.id);
    option.classList.remove("highlighted");
    selectedOption = -1;
    hideOptions();
    confirmInput(input, focusNext);
  }

  // hide the dropdown
  function hideOptions() {
    optionList.style.display = 'none';
  };
  
  /** @param {HTMLElement} elem */
  function addDropdownEvents(elem) {
    elem.addEventListener('focus', inputFocusIn);
    elem.addEventListener('focusout', inputFocusOut);
    elem.addEventListener('input', inputFocusIn);
    elem.addEventListener('keydown', handleOptionKeyNav);
    if (properties.dropdownButton)
      elem.nextElementSibling.addEventListener('click', dropdownButtonClick);
  }

  /** @param {HTMLElement} elem */
  function removeDropdownEvents(elem) {
    elem.removeEventListener('focus', filterOptions);
    elem.removeEventListener('input', filterOptions);
    elem.removeEventListener('keydown', handleOptionKeyNav);
    elem.removeEventListener('focusout', inputFocusOut);
    if (properties.dropdownButton)
      elem.nextElementSibling.removeEventListener('click', dropdownButtonClick);
  }

  /** @param {HTMLInputElement} textbox */
  function confirmInput(textbox, focusNext) {
    if(properties.multiSelect){
      const lastInput = allInputs[allInputs.length - 1];
      if(input != lastInput && focusNext){
        input = lastInput;
      }
      else{
        /** @type {HTMLInputElement} */
        const newInputContainer = input.parentElement.cloneNode(true);
        const newInput = newInputContainer.querySelector('input');
        newInput.value = "";
        addDropdownEvents(newInput);
        input.parentNode.parentNode.appendChild(newInputContainer);
        allInputs.push(newInput);
        if(focusNext) input = newInput;
      }
      if(focusNext) {
        input.focus();
        hideOptions();
      }
    }
    else {
      input.setAttribute('data-id', -1);
      hideOptions();
    }
  }

})()</script>
